{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#netcdfjl","title":"NetCDF.jl","text":"<p>Reading and writing NetCDF files in Julia</p> <p>NetCDF support for the Julia programming language, is a high-level and a medium-level interface for writing and reading <code>netcdf</code> files.</p> <p>Package features</p> <ul> <li>High-level (MATLAB-like), low-level (C-like) and array-based access to NetCDF files.</li> </ul> <p>Start by adding the package:</p> <pre><code>]\nadd NetCDF\n</code></pre> <p>Acknowledgements</p> <p>Thanks to everyone who contributed to the package with pull requests, especially to Martijn Visser for creating the new generated C wrapper.</p>"},{"location":"reference/","title":"High-level interface","text":""},{"location":"reference/#high-level-interface","title":"High-level interface","text":""},{"location":"reference/#getting-information","title":"Getting information","text":"<p># <code>NetCDF.ncinfo</code> \u2014 Function.</p> <pre><code>ncinfo(filename)\n</code></pre> <p>prints information on the variables, dimension and attributes conatained in the file</p> <p>source</p> <p></p> <p></p>"},{"location":"reference/#reading-data","title":"Reading data","text":"<p># <code>NetCDF.ncread</code> \u2014 Function.</p> <pre><code>ncread(filename, varname)\n</code></pre> <p>reads the values of the variable <code>varname</code> from file <code>filename</code> and returns the values in an array.</p> <p>Keyword arguments</p> <ul> <li><code>start</code> Vector of length <code>ndim(v)</code> setting the starting index for each dimension</li> <li><code>count</code> Vector of length <code>ndim(v)</code> setting the count of values to be read along each dimension. The value -1 is treated as a special case to read all values along the dimension</li> </ul> <p>Example</p> <p>To read the second slice of a 3D NetCDF variable, you can write:</p> <pre><code>ncread(\"filename\",\"varname\", start=[1,1,2], count = [-1,-1,1])\n</code></pre> <p>source</p> <p># <code>NetCDF.ncread!</code> \u2014 Function.</p> <pre><code>ncread!(filename, varname, d)\n</code></pre> <p>reads the values of the variable varname from file filename and writes the results to the pre-allocated array <code>d</code></p> <p>Keyword arguments</p> <ul> <li><code>start</code> Vector of length <code>ndim(v)</code> setting the starting index for each dimension</li> <li><code>count</code> Vector of length <code>ndim(v)</code> setting the count of values to be read along each dimension. The value -1 is treated as a special case to read all values from this dimension</li> </ul> <p>Example</p> <p>To read the second slice of a 3D NetCDF variable one can write:</p> <pre><code>d = zeros(10,10,1)\nncread!(\"filename\",\"varname\", d, start=[1,1,2], count = [-1,-1,1])\n</code></pre> <p>source</p> <p></p> <p></p>"},{"location":"reference/#writing-data","title":"Writing data","text":"<p># <code>NetCDF.ncwrite</code> \u2014 Function.</p> <pre><code>ncwrite(x::Array,fil::AbstractString,vname::AbstractString)\n</code></pre> <p>Writes the array <code>x</code> to the file <code>fil</code> and variable <code>vname</code>.</p> <p>Keyword arguments</p> <ul> <li><code>start</code> Vector of length <code>ndim(v)</code> setting the starting index for writing for each dimension</li> <li><code>count</code> Vector of length <code>ndim(v)</code> setting the count of values to be written along each dimension. The value -1 is treated as a special case to write all values along the dimension. This is usually inferred by the given array size.</li> </ul> <p>source</p> <p></p> <p></p>"},{"location":"reference/#reading-attributes","title":"Reading attributes","text":"<p># <code>NetCDF.ncgetatt</code> \u2014 Function.</p> <pre><code>ncgetatt(filename, varname, attname)\n</code></pre> <p>This reads a NetCDF attribute <code>attname</code> from the specified file and variable. To read global attributes, set varname to <code>Global</code>.</p> <p>source</p> <p></p> <p></p>"},{"location":"reference/#writing-attributes","title":"Writing attributes","text":"<p># <code>NetCDF.ncputatt</code> \u2014 Function.</p> <pre><code>ncputatt(nc::String,varname::String,atts::Dict)\n</code></pre> <p>Writes the attributes defined in <code>atts</code> to the variable <code>varname</code> for the given NetCDF file name <code>nc</code>. Existing attributes are overwritten. If varname is not a valid variable name, a global attribute will be written.</p> <p>source</p> <p></p> <p></p>"},{"location":"reference/#creating-files","title":"Creating files","text":"<p># <code>NetCDF.nccreate</code> \u2014 Function.</p> <pre><code>nccreate (filename, varname, dimensions ...)\n</code></pre> <p>Creates a variable in an existing NetCDF file or generates a new file. <code>filename</code> and <code>varname</code> are strings. After that follows a list of dimensions. Each dimension entry starts with a dimension name (a String), and may be followed by a dimension length, an array with dimension values or a Dict containing dimension attributes. Then the next dimension is entered and so on. Have a look at examples/high.jl for an example use.</p> <p>Keyword arguments</p> <ul> <li>atts Dict of attribute names and values to be assigned to the variable created</li> <li>gatts Dict of attribute names and values to be written as global attributes</li> <li>compress Integer [0..9] setting the compression level of the file, only valid if <code>mode=NC_NETCDF4</code></li> <li>t variable type, currently supported types are: const <code>NC_BYTE</code>, <code>NC_CHAR</code>, <code>NC_SHORT</code>, <code>NC_INT</code>, <code>NC_FLOAT</code>, <code>NC_LONG</code>, <code>NC_DOUBLE</code></li> <li>mode file creation mode, only valid when new file is created, choose one of: <code>NC_NETCDF4</code>, <code>NC_CLASSIC_MODEL</code>, <code>NC_64BIT_OFFSET</code></li> </ul> <p>source</p>"},{"location":"strings/","title":"Strings","text":""},{"location":"strings/#short-note-on-reading-and-writing-nc_char-and-nc_string-variables","title":"Short note on reading and writing <code>NC_CHAR</code> and <code>NC_STRING</code> variables","text":"<p>There are two common types for storing String data in NetCDF variables. The first is <code>NC_CHAR</code>, where a 1D array of strings is stored in a 2D <code>char**</code> array. Here the user must define the maximum string length and add a respective NetCDF dimension. Since NetCDF4 there is the <code>NC_STRING</code> data type that allows  the direct definition of String variables so that an N-dimensional String array directly maps to an N-dimensional  array in the NetCDF file structure.</p> <p></p> <p></p>"},{"location":"strings/#nc_string-variables","title":"<code>NC_STRING</code> variables","text":"<p>In this package, the Julia type <code>String</code> maps to the <code>NC_STRING</code> datatype, which means that creating a variable with any of</p> <pre><code>nccreate(filename, varname, dims..., t=String)\n</code></pre> <p>or</p> <pre><code>NcVar(varname,dims,t=String)\n</code></pre> <p>will result in a NetCDF variable of type <code>NC_STRING</code>. You can directly write an <code>Array{String}</code> of matching shape to these variables. Similarly, calling <code>ncread</code> or <code>NetCDF.readvar</code> on any of these variables will return an <code>Array{String}</code></p> <p></p> <p></p>"},{"location":"strings/#nc_char-variables","title":"<code>NC_CHAR</code> variables","text":"<p>Dealing with <code>NC_CHAR</code> variables is a bit more complicated because of two reasons. First, the dimensions of the NetCDF variables do not match the dimensions of the resulting string array because of the additional <code>str_len</code> (or similar) axis that is introduced in the NetCDF file. So an n-dimensional String-Array maps to an (n+1)-dimensional <code>NC_CHAR</code> array.</p> <p>Second, historically the <code>NC_CHAR</code> type has been used to store compressed data, too. So it is not always desirable to automatically convert these char arrays to strings. Anyhow, here is how you can deal with these variable types:</p> <p>Assume you have a NetCDF variable of type <code>NC_CHAR</code> of dimensions (str_len: 10, axis2: 20). Calling <code>x=ncread(...)</code> or <code>x=readvar(...)</code> on this variable will return an <code>Array{ASCIIChar,2}</code> with size <code>(10,20)</code> as it is represented on disk. The <code>ASCIIChar</code> type is a small wrapper around <code>UInt8</code>, needed for dispatch. You can simply convert them to either <code>Char</code> or <code>UInt8</code> using the <code>convert</code> function. The returned array can either be used directly (if it is numeric, you might be able to use <code>reinterpret(UInt8,x)</code>) or convert them to a <code>Vector{String}</code> by calling</p> <pre><code>y=nc_char2string(x)\n</code></pre> <p>which will return a string vector of length 20.</p> <p>An example for creating <code>NC_CHAR</code> and writing variables would be the following:</p> <pre><code>nccreate(filename,varname,\"str_len\",20,\"DimValues\",5,t=NC_CHAR)\nxs = [\"a\",\"bb\",\"ccc\",\"dddd\",\"eeeee\"]\nncwrite(filename,varname,nc_string2char(xs))\n</code></pre> <p>The call of <code>string2char</code> will convert the <code>Vector{String}</code> to a <code>Matrix{UInt8}</code>. which can be written to the NetCDF file.</p>"},{"location":"scripts/generated/guide/attributes/","title":"Attributes","text":"<pre><code>using NetCDF\n</code></pre> <p>This page was generated using Literate.jl.</p>"},{"location":"scripts/generated/guide/dimensions/","title":"Dimensions","text":"<pre><code>using NetCDF\n</code></pre> <p>This page was generated using Literate.jl.</p>"},{"location":"scripts/generated/guide/open_read/","title":"Open, read, create","text":""},{"location":"scripts/generated/guide/open_read/#open-a-file","title":"Open a file","text":"<p># <code>NetCDF.open</code> \u2014 Function.</p> <pre><code>NetCDF.open(fil::AbstractString,v::AbstractString)\n</code></pre> <p>opens a NetCDF variable <code>v</code> in the NetCDF file <code>fil</code> and returns an <code>NcVar</code> handle that implements the <code>AbstractArray</code> interface for reading and writing. Note that it is in the user's responsibility to close the file after usage using <code>NetCDF.close</code>.</p> <p>Keyword arguments</p> <ul> <li><code>mode</code> mode in which the file is opened, defaults to <code>NC_NOWRITE</code>, choose <code>NC_WRITE</code> for write access</li> <li><code>readdimvar</code> determines if dimension variables will be read into the file structure, default is <code>false</code></li> </ul> <p>source</p> <pre><code>NetCDF.open(fil::AbstractString)\n</code></pre> <p>opens the NetCDF file <code>fil</code> and returns a <code>NcFile</code> handle. Note that it is in the user's responsibility to close the file after usage using <code>NetCDF.close</code>.</p> <p>Keyword arguments</p> <ul> <li><code>mode</code> mode in which the file is opened, defaults to <code>NC_NOWRITE</code>, choose <code>NC_WRITE</code> for write access</li> <li><code>readdimvar</code> determines if dimension variables will be read into the file structure, default is <code>false</code></li> </ul> <p>source</p> <pre><code>NetCDF.open(f::Function, args...;kwargs...)\n</code></pre> <p>Opens a NetCDF file, applies the function f on the resulting file or variable handle and properly closes the file after usage. This is convenient to use together with the <code>do</code> block syntax, for example:</p> <pre><code>data = open(\"myfile.nc\",\"myvar\") do v\n    NetCDF.readvar(v,start=[1,1,1], count=[-1,-1,1])\nend\n</code></pre> <p>source</p> <p></p> <p></p>"},{"location":"scripts/generated/guide/open_read/#getting-information","title":"Getting information","text":"<p>The <code>NetCDF.open</code> function returns an object of type <code>NcFile</code> which contains meta-Information about the file and associated variables. You can index the <code>NcFile</code> object <code>nc[varname]</code> to retrieve an <code>NcVar</code> object and retrieve information about it. You can run <code>keys(nc)</code> to get a list of available variables.</p> <p>Most of the following functions of the medium-level interface will use either an <code>NcFile</code> or an <code>NcVar</code> object as their first argument.</p> <p></p> <p></p>"},{"location":"scripts/generated/guide/open_read/#reading-data","title":"Reading data","text":"<p># <code>NetCDF.readvar</code> \u2014 Function.</p> <pre><code>NetCDF.readvar(v::NcVar;start::Vector=ones(UInt,ndims(d)),count::Vector=size(d))\n</code></pre> <p>Reads the values from the file associated to the <code>NcVar</code> object <code>v</code> and returns them. By default the whole variable is read</p> <p>Keyword arguments</p> <ul> <li><code>start</code> Vector of length <code>ndim(v)</code> setting the starting index for each dimension</li> <li><code>count</code> Vector of length <code>ndim(v)</code> setting the count of values to be read along each dimension. The value -1 is treated as a special case to read all values from this dimension</li> </ul> <p>Example</p> <p>Assume <code>v</code> is a NetCDF variable with dimensions (3,3,10).</p> <pre><code>x = NetCDF.readvar(v, start=[1,2,1], count=[3,1,-1])\n</code></pre> <p>This reads all values from the first and last dimension and only the second value from the second dimension.</p> <p>source</p> <pre><code>NetCDF.readvar{T,N}(v::NcVar{T,N},I::Union{Integer, UnitRange, Colon}...)\n</code></pre> <p>Reads data from a NetCDF file with array-style indexing. <code>Integer</code>s and <code>UnitRange</code>s and <code>Colon</code>s are valid indices for each dimension.</p> <p>source</p> <p></p> <p></p>"},{"location":"scripts/generated/guide/open_read/#writing-data","title":"Writing data","text":"<p># <code>NetCDF.putvar</code> \u2014 Function.</p> <pre><code>NetCDF.putvar(v::NcVar,vals::Array;start::Vector=ones(Int,length(size(vals))),count::Vector=[size(vals)...])\n</code></pre> <p>Writes the values from the array <code>vals</code> to a NetCDF file. <code>v</code> is the <code>NcVar</code> handle of the respective variable and <code>vals</code> is an array with the same dimension as the variable in the NetCDF file.</p> <p>Keyword arguments</p> <ul> <li><code>start</code> Vector of length <code>ndim(v)</code> setting the starting index for each dimension</li> <li><code>count</code> Vector of length <code>ndim(v)</code> setting the count of values to be read along each dimension. The value -1 is treated as a special case to read all values from this dimension</li> </ul> <p>source</p> <pre><code>NetCDF.putvar(v::NcVar, val, i...)\n</code></pre> <p>Writes the value(s) <code>val</code> to the variable <code>v</code> while the indices are given in in an array-style indexing manner.</p> <p>source</p> <p></p> <p></p>"},{"location":"scripts/generated/guide/open_read/#creating-files","title":"Creating files","text":"<p>To create a NetCDF file you first have to define the dimensions and variables that it is supposed to hold. As representations for NetCDF dimensions and variables there are the predefined <code>NcVar</code> and <code>NcDim</code> types. An <code>NcDim</code> object is created by:</p> <pre><code>NcDim(dimname, dimlength, atts=Dict{Any,Any}(); values=[], unlimited=false)\n</code></pre> <p># <code>NetCDF.NcDim</code> \u2014 Type.</p> <pre><code>NcDim\n</code></pre> <p>Represents a NetCDF dimension of name <code>name</code> optionally holding the dimension values.</p> <p>source</p> <p>here <code>dimname</code> is the dimension name, <code>dimlength</code> is the dimension length. The optional argument <code>values</code> is a 1D array of values that are written to the dimension variable and the optional argument <code>atts</code> is a <code>Dict</code> holding pairs of attribute names and values. Setting <code>unlimited=true</code> creates an unlimited dimension.</p> <p>After defining the dimensions, you can create <code>NcVar</code> objects with</p> <pre><code>NcVar(varname , dimlist; atts=Dict{Any,Any}(), t=Float64, compress=-1)\n</code></pre> <p># <code>NetCDF.NcVar</code> \u2014 Type.</p> <pre><code>NcVar\n</code></pre> <p><code>NcVar{T,N,M}</code> represents a NetCDF variable. It is a subtype of <code>AbstractArray{T,N}</code>, so normal indexing using <code>[]</code> will work for reading and writing data to and from a NetCDF file. <code>NcVar</code> objects are returned by <code>NetCDF.open</code>, by indexing an <code>NcFile</code> object (e.g. <code>myfile[\"temperature\"]</code>) or, when creating a new file, by its constructor. The type parameter <code>M</code> denotes the NetCDF data type of the variable, which may or may not correspond to the Julia Data Type.</p> <p>source</p> <p>Here <code>varname</code> is the name of the variable, <code>dimlist</code> an array of type <code>NcDim</code> holding the dimensions associated to the variable, <code>atts</code> is a Dict holding pairs of attribute names and values. <code>t</code> is the data type that should be used for storing the variable.  You can either specify a Julia type (<code>Int16</code>, <code>Int32</code>, <code>Int64</code>, <code>Float32</code>, <code>Float64</code>) which will be translated to (<code>NC_SHORT</code>, <code>NC_INT</code>, <code>NC_INT64</code>, <code>NC_FLOAT</code>, <code>NC_DOUBLE</code>) or directly specify one of the latter list. You can also set the compression level of the variable by setting <code>compress</code> to a number in the range 1..9 This has only an effect in <code>NetCDF4</code> files.</p> <p>example</p> <p>please, help with an example for this (mwe, copy/paste), it will be better for understanding.</p> <p></p> <p></p>"},{"location":"scripts/generated/guide/open_read/#_1","title":"Open, read, create","text":"<p>Having defined the variables, the NetCDF file can be created:</p> <pre><code>NetCDF.create(filename, varlist, gatts=Dict{Any,Any}(),mode=NC_NETCDF4)\n</code></pre> <p>Here, <code>filename</code> is the name of the file to be created and <code>varlist</code> an array of <code>NcVar</code> holding the variables that should appear in the file. In the optional argument <code>gatts</code> you can specify a Dict containing global attributes and <code>mode</code> is the file type you want to create (<code>NC_NETCDF4</code>, <code>NC_CLASSIC_MODEL</code> or <code>NC_64BIT_OFFSET</code>).</p> <p># <code>NetCDF.create</code> \u2014 Function.</p> <pre><code>NetCDF.create(name::AbstringString,varlist::Array{NcVar};gatts::Dict=Dict{Any,Any}(),mode::UInt16=NC_NETCDF4,add_finalizer = true)\n</code></pre> <p>Creates a new NetCDF file. Here, <code>name</code>  is the name of the file to be created and <code>varlist</code> an array of <code>NcVar</code> holding the variables that should appear in the file.</p> <p>Keyword arguments</p> <ul> <li><code>gatts</code> a Dict containing global attributes of the NetCDF file</li> <li><code>mode</code> NetCDF file type (<code>NC_NETCDF4</code>, <code>NC_CLASSIC_MODEL</code> or <code>NC_64BIT_OFFSET</code>), defaults to <code>NC_NETCDF4</code></li> </ul> <p>source</p> <pre><code>NetCDF.create(f::Function, args...;kwargs...)\n</code></pre> <p>Creates a NetCDF file, applies the function <code>f</code> on the resulting file or variable handle and properly closes the file after usage. This is convenient to use together with the <code>do</code> block syntax, for example:</p> <pre><code>d = NcDim(\"time\",1:10)\nv = NcVar(\"obs\",d);\nNetCDF.create(\"newfile.nc\",v) do nc\n    nc[\"obs\"][:] = rand(10)\nend\n</code></pre> <p>source</p> <p></p> <p></p>"},{"location":"scripts/generated/guide/open_read/#finalizers-sync","title":"Finalizers, sync","text":"<p>Note that as of version 0.9 there is no need to close the <code>NetCDF</code> files anymore. This will be done through finalizers.</p> <p>If you just want to synchronize your changes to the disk, run</p> <pre><code>NetCDF.sync(nc)\n</code></pre> <p>where <code>nc</code> is a <code>NetCDF</code> file handle.</p> <p>As an alternative, <code>NetCDF.open</code> and <code>NetCDF.create</code> provide a method accepting a function as its first argument.</p> <p>This page was generated using Literate.jl.</p>"},{"location":"scripts/generated/guide/performance/","title":"Performance tips?","text":"<pre><code>using NetCDF\n</code></pre> <p>This page was generated using Literate.jl.</p>"},{"location":"scripts/generated/guide/quick_start/","title":"Quick start","text":""},{"location":"scripts/generated/guide/quick_start/#quickstart","title":"Quickstart","text":""},{"location":"scripts/generated/guide/quick_start/#reading-a-file","title":"Reading a file","text":"<p>The most common task is probably to just read a <code>NetCDF</code> file into memory. This is done with:</p> <p><code>ncread(filename, varname)</code></p> <p>This reads the whole variable into memory and returns it as a Julia array. To read only a slice of a <code>NetCDF</code> file, there are optional <code>start</code> and <code>count</code> keyword arguments, where one can specify the starting index and count along each dimension.</p> <p></p> <p></p>"},{"location":"scripts/generated/guide/quick_start/#example","title":"Example","text":"<p>In this example we show how to create a <code>NetCDF</code> file from scratch, write some data to it and read it back in afterwards. First of all we create an array with top-of the atmosphere radiation data:</p> <pre><code>using NetCDF\ninclude(joinpath(dirname(pathof(NetCDF)), \"../docs/scripts/guide/toa.jl\"))\n</code></pre> <pre><code>g_pot (generic function with 1 method)\n</code></pre> <p>Define longitudes and latitudes, day and timesteps</p> <pre><code>lat = -89.5:89.5\nlon = -179.5:179.5\nday = 1\ntempo = 0:23;\n</code></pre> <p></p> <p></p>"},{"location":"scripts/generated/guide/quick_start/#create-radiation-array","title":"Create radiation array","text":"<pre><code>rad = [g_pot(la, lo, day, t) for lo in lon, la in lat, t in tempo];\n</code></pre> <p>The resulting array is a 3-dimensional array with dimensions lon-lat-time, resembling approximately the hourly top of atmosphere radiation on January 1st. For documentation purposes we want to add atributes to the variable as well as the dimensions. Throughout this package, attributes are represented <code>Dict{String}</code>s:</p> <p></p> <p></p>"},{"location":"scripts/generated/guide/quick_start/#add-atributes","title":"add atributes","text":"<pre><code>varatts = Dict(\"longname\" =&gt; \"Radiation at the top of the atmosphere\",\n\"units\"    =&gt; \"W/m^2\")\nlonatts = Dict(\"longname\" =&gt; \"Longitude\",\n\"units\"    =&gt; \"degrees east\")\nlatatts = Dict(\"longname\" =&gt; \"Latitude\",\n\"units\"    =&gt; \"degrees north\")\ntimatts = Dict(\"longname\" =&gt; \"Time\",\n\"units\"    =&gt; \"hours since 01-01-2000 00:00:00\");\n</code></pre> <p>Now we have all the meta-information ready to create the actual file.</p> <p></p> <p></p>"},{"location":"scripts/generated/guide/quick_start/#save-file","title":"save file","text":"<pre><code>fn = \"radiation.nc\"\nisfile(fn) &amp;&amp; rm(fn) # clear create\n\nnccreate(fn, \"rad\",\n\"lon\", lon, lonatts,\n\"lat\", lat, latatts,\n\"time\", tempo, timatts,\natts=varatts);\n</code></pre> <p>Once the file is created we can write the actual data to it:</p> <pre><code>ncwrite(rad, fn, \"rad\")\n</code></pre> <p></p> <p></p>"},{"location":"scripts/generated/guide/quick_start/#ncinfo","title":"ncinfo","text":"<p>Now we assume we just retrieved this radiation <code>NetCDF</code> file and want to get some information about it. This is done using <code>ncinfo</code>:</p> <pre><code>ncinfo(fn)\n</code></pre> <pre><code>##### NetCDF File #####\n\n/home/runner/work/NetCDF.jl/NetCDF.jl/docs/docs/scripts/generated/guide/radiation.nc\n\n##### Dimensions #####\n\nName                                                Length\n--------------------------------------------------------------------------------\nlat                                                 180\ntime                                                24\nlon                                                 360\n\n##### Variables #####\n\nName                            Type            Dimensions\n--------------------------------------------------------------------------------\nlat                             DOUBLE          lat\ntime                            INT64           time\nlon                             DOUBLE          lon\nrad                             DOUBLE          lon lat time\n\n##### Attributes #####\n\nVariable            Name                Value\n--------------------------------------------------------------------------------\nlat                 units               degrees north\nlat                 longname            Latitude\ntime                units               hours since 01-01-2000 00:00:00\ntime                longname            Time\nlon                 units               degrees east\nlon                 longname            Longitude\nrad                 units               W/m^2\nrad                 longname            Radiation at the top of the atmosphere\n</code></pre> <p>Here we learn the most important information about the file, which variables it contains, the variable dimensions and their attributes. We decide to read the radiation variable:</p> <pre><code>x = ncread(fn,\"rad\");\nsize(x)\n</code></pre> <pre><code>(360, 180, 24)\n</code></pre> <p></p> <p></p>"},{"location":"scripts/generated/guide/quick_start/#slicing","title":"slicing","text":"<p>This reads the whole array at once. If we only want to read a certain part of the variable, for example if we only want to plot the time series at a certain location, we can use the <code>start</code> and <code>count</code> keywords:</p> <pre><code>ts = ncread(fn, \"rad\", start=[180,45,1], count=[1,1,-1])\n</code></pre> <pre><code>1\u00d71\u00d724 Array{Float64, 3}:\n[:, :, 1] =\n 0.0\n\n[:, :, 2] =\n 0.0\n\n[:, :, 3] =\n 0.0\n\n;;; \u2026 \n\n[:, :, 22] =\n 0.0\n\n[:, :, 23] =\n 0.0\n\n[:, :, 24] =\n 0.0\n</code></pre> <p></p> <p></p>"},{"location":"scripts/generated/guide/quick_start/#time-series-plot","title":"time series plot","text":"<p>In order to correctly label the time steps we retrieve the time information from the file:</p> <pre><code>using Dates\ntvec = DateTime(2001,1,1) + Hour.(ncread(fn,\"time\"))\n</code></pre> <pre><code>24-element Vector{Dates.DateTime}:\n 2001-01-01T00:00:00\n 2001-01-01T01:00:00\n 2001-01-01T02:00:00\n 2001-01-01T03:00:00\n 2001-01-01T04:00:00\n 2001-01-01T05:00:00\n 2001-01-01T06:00:00\n 2001-01-01T07:00:00\n 2001-01-01T08:00:00\n 2001-01-01T09:00:00\n \u22ee\n 2001-01-01T15:00:00\n 2001-01-01T16:00:00\n 2001-01-01T17:00:00\n 2001-01-01T18:00:00\n 2001-01-01T19:00:00\n 2001-01-01T20:00:00\n 2001-01-01T21:00:00\n 2001-01-01T22:00:00\n 2001-01-01T23:00:00\n</code></pre> <p>Now we can generate the plot:</p> <pre><code>using CairoMakie\n</code></pre> <p>manual time ticks</p> <pre><code>tempo = string.(tvec)\nlentime = length(tempo)\nslice_dates = range(1, lentime, step=lentime \u00f7 8)\n</code></pre> <pre><code>1:3:22\n</code></pre> <p>the actual plot</p> <pre><code>fig, ax, obj = lines(1:length(tvec), ts[1,1,:])\nax.xticks = (slice_dates, tempo[slice_dates])\nax.xticklabelrotation = \u03c0 / 2\nax.xticklabelalign = (:right, :center)\nfig\n</code></pre> <p></p> <p></p> <p></p>"},{"location":"scripts/generated/guide/quick_start/#heatmap-plot","title":"Heatmap plot","text":"<p>Another example would be to generate a heatmap plot of the solar radiation at 12am UTC:</p> <pre><code>lons = ncread(fn, \"lon\")\nlats = ncread(fn, \"lat\")\nm = ncread(fn, \"rad\", start=[1,1,12], count=[-1,-1,1]);\nheatmap(lons, lats, m[:,:,1]; colormap = :plasma,\naxis = (; xlabel = \"lon\", ylabel = \"lat\"))\n</code></pre> <p></p> <p>This page was generated using Literate.jl.</p>"},{"location":"scripts/generated/guide/toa/","title":"Toa","text":"<pre><code>function g_pot(latitude, longitude, d_, t_)\n\nstandardmeridian = longitude\n\nlocalstandardtime = t_\ntthet = 2\u03c0 * (d_ - 1.0) / 365.0\n\neqoftime = (0.000075 + 0.001868 * cos(tthet) - 0.032077 * sin(tthet) -\n0.014615 * cos(2 * tthet) - 0.040849 * sin(2 * tthet)) * 229.18\n\nlocalapparentsolartime = localstandardtime + eqoftime / 60 + longitude / 15\nsignedLAS = 12 - localapparentsolartime\n\nsignedLAS = abs(signedLAS)\nomega = -15 * signedLAS\n\ndecl_rad = 0.006918 - 0.399912 * cos(tthet) + 0.070257 * sin(tthet) -\n0.006758 * cos(2 * tthet) + 0.000907 * sin(2 * tthet) -\n0.002697 * cos(3 * tthet) + 0.00148 * sin(3 * tthet)\nlat_rad = deg2rad(latitude)\nlong_rad = deg2rad(longitude)\n\ntheta_rad = acos(sin(decl_rad) * sin(lat_rad) +\ncos(decl_rad) * cos(lat_rad) * cos(omega * \u03c0 / 180.0))\n\ndt = d_ + t_ / 24\n\nsolarconst = 1376\n\nRpot = solarconst * (1.00011 + 0.034221 * cos(tthet) + 0.00128 * sin(tthet) +\n0.000719 * cos(2 * tthet) + 0.000077 * sin(2 * tthet))\n\nRpot_h = Rpot * cos(theta_rad)\nRpot_h = cos(theta_rad) &lt; 0.0 ? 0.0 : Rpot_h\nreturn Rpot_h\nend\n</code></pre> <pre><code>g_pot (generic function with 1 method)\n</code></pre> <p>This page was generated using Literate.jl.</p>"},{"location":"scripts/generated/guide/variables/","title":"Variables","text":"<pre><code>using NetCDF\n</code></pre> <p>This page was generated using Literate.jl.</p>"}]}